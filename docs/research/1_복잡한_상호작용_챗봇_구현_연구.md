# **LangGraph를 활용한 복잡계 멀티 에이전트 챗봇 아키텍처 설계 및 구현: 기술 백서**

## **서론**

최근 대규모 언어 모델(LLM)의 발전은 단순한 질의응답을 넘어, 복잡한
작업을 자율적으로 수행하고 사용자와 지속적으로 상호작용할 수 있는
\'에이전트(Agent)\'라는 새로운 패러다임을 제시했습니다. 그러나 단일
에이전트 모델은 여러 도구를 다루거나 복잡한 다단계 추론을 수행할 때
명백한 한계에 부딪힙니다. 이러한 한계를 극복하기 위해, 여러 전문
에이전트가 협력하여 문제를 해결하는 멀티 에이전트 시스템(Multi-Agent
Systems)이 핵심적인 해결책으로 부상하고 있습니다.

LangGraph는 이러한 정교한 멀티 에이전트 시스템을 구축하기 위해 설계된
강력한 프레임워크입니다. LangChain의 개발자들이 만들었지만, 전통적인
선형적 체인(Chain) 구조를 근본적으로 뛰어넘는 새로운 접근 방식을
제공합니다.^1^ LangGraph의 핵심은 AI 워크플로우를 상태를 가진 순환
그래프(Stateful, Cyclical Graph)로 모델링하는 것입니다. 이를 통해
개발자는 에이전트의 행동을 제어하고, 동적으로 경로를 결정하며, 장기적인
대화의 맥락을 유지하고, 필요시 사람의 개입을 허용하는 등, 기존
프레임워크로는 구현하기 어려웠던 복잡하고 유연한 제어 흐름을 설계할 수
있습니다.^2^

본 기술 백서는 LangGraph를 사용하여 단순한 챗봇을 넘어, 다수의 전문
에이전트가 유기적으로 상호작용하는 복잡계 멀티 에이전트 챗봇을 구현하기
위한 심층적인 아키텍처와 구체적인 방법론을 제시하는 것을 목표로 합니다.
LangGraph의 기본 원리인 StateGraph와 상태 관리부터 시작하여, 동적
라우팅을 가능하게 하는 조건부 엣지, 외부 세계와의 상호작용을 위한 도구
호출, 그리고 대화의 연속성을 보장하는 메모리 아키텍처를 상세히
분석합니다.

나아가, 본 백서는 Supervisor-Worker, 계층적 에이전트 팀(Hierarchical
Agent Teams), Plan-and-Execute와 같은 핵심적인 멀티 에이전트 설계 패턴을
구체적인 코드 예제와 함께 심도 있게 다룰 것입니다. 각 아키텍처의 개념적
프레임워크, 구현 세부 사항, 그리고 실제 적용 사례를 분석함으로써, AI
개발자와 시스템 아키텍트가 자신의 요구사항에 맞는 견고하고 확장 가능한
에이전트 시스템을 설계하고 구축할 수 있도록 실질적인 청사진을 제공하고자
합니다.

## **1. 에이전트 시스템을 위한 LangGraph의 기본 원리** {#에이전트-시스템을-위한-langgraph의-기본-원리}

LangGraph 기반의 에이전트 시스템을 구축하기 위해서는 먼저 그 근간을
이루는 핵심 개념들을 이해해야 합니다. LangGraph는 단순한 라이브러리를
넘어, 상태 기반의 순환적 연산을 통해 지능형 시스템을 구축하는 새로운
패러다임을 제시합니다. 이 섹션에서는 모든 에이전트 아키텍처의 기초가
되는 StateGraph, 상태 설계, 그리고 노드와 엣지의 개념을 심층적으로
분석합니다.

### **1.1. StateGraph: 상태 기반 순환 연산 패러다임** {#stategraph-상태-기반-순환-연산-패러다임}

LangGraph의 가장 핵심적인 구성요소는 StateGraph입니다. 이는 AI
워크플로우를 상태를 가진 유향 그래프(Directed Graph)로 표현하는 강력한
추상화입니다.^1^ 전통적인 LangChain의 \'체인\'이 대부분 단방향의 비순환
그래프(DAG, Directed Acyclic Graph) 구조를 가지는 반면,

StateGraph는 순환(Cycle)을 허용하는 것이 가장 큰 특징입니다. 이 순환
구조는 에이전트가 특정 작업을 반복적으로 시도하거나, 실패 시 스스로
수정하고, 사용자의 피드백을 받아 행동을 개선하는 등 진정한 의미의
에이전트적 행동을 구현하는 데 필수적입니다.^1^

그래프는 두 가지 기본 요소로 구성됩니다:

- **노드(Nodes):** 그래프 내에서 실제 작업을 수행하는 계산 단위입니다.
  > 각 노드는 하나의 Python 함수 또는 LangChain 실행 가능
  > 객체(Runnable)로 표현될 수 있습니다.^1^

- **엣지(Edges):** 노드 간의 연결을 정의하며, 데이터와 제어의 흐름을
  > 결정합니다. 엣지는 한 노드의 작업이 끝난 후 다음으로 어떤 노드를
  > 실행할지 지정합니다.^1^

이러한 구조의 진정한 힘은 \'상태(State)\'의 존재에서 비롯됩니다.
그래프의 모든 노드와 엣지는 공유된 상태 객체에 접근하고 이를 수정할 수
있습니다. 이 상태는 전체 워크플로우의 현재 스냅샷을 나타내며, 각 노드는
이 상태를 입력으로 받아 작업을 수행한 후, 변경된 상태를 다음 노드로
전달합니다.^1^ 이러한 상태 지속성 덕분에 LangGraph는 재시도(Retry) 로직,
자기 수정 루프(Self-correction Loop), 그리고 인간 참여형
워크플로우(Human-in-the-loop)와 같은 복잡한 상호작용을 모델링할 수
있습니다.^1^

LangGraph는 단순히 LLM을 위한 프레임워크에 그치지 않습니다. 그 본질은
범용적인 상태 기계(State Machine) 프레임워크에 가깝습니다.^5^ 노드
내에서 수행되는 작업이 LLM 호출일 수도 있지만, 데이터베이스 쿼리, API
호출, 복잡한 비즈니스 로직 실행 등 어떤 Python 코드도 될 수 있습니다.
즉, \'AI\'는 그래프의 구조가 아닌 노드의 \'내용\'에 의해 결정됩니다.
이는 개발자가 LLM 기반의 에이전트 로직과 비(非)LLM 기반의 전통적인
소프트웨어 로직을 동일한 오케스트레이션 계층 내에서 통합하여, 더욱
강력하고 통일된 시스템을 구축할 수 있음을 시사합니다.

또한, LangGraph는 그래프 구조를 시각화하는 기능을 제공합니다.
draw_mermaid_png()와 같은 메서드를 사용하면 복잡한 에이전트 상호작용의
흐름을 한눈에 파악할 수 있어, 시스템 설계와 디버깅 과정에서 매우 중요한
역할을 합니다.^4^

### **1.2. 상태 아키텍처: TypedDict와 Pydantic의 중심적 역할** {#상태-아키텍처-typeddict와-pydantic의-중심적-역할}

LangGraph 애플리케이션에서 \'상태(State)\'는 \"가장 본질적인
구성요소\"라고 할 수 있습니다.^1^ 상태는 그래프 내의 모든 노드와 엣지
간에 전달되는 공유 데이터 구조로, 애플리케이션의 현재 상황을 담고 있는
스냅샷 역할을 합니다. 이 상태 객체는 일반적으로 Python의

TypedDict나 Pydantic의 BaseModel을 사용하여 명시적으로 스키마를
정의합니다.^3^

상태 스키마를 설계하는 것은 단순히 데이터 컨테이너를 만드는 것을 넘어,
전체 애플리케이션의 데이터 흐름과 잠재적 능력을 규정하는 시스템 아키텍처
설계 행위 그 자체입니다. 잘 설계된 상태 객체는 입력, 중간 결과, 오류
플래그, 최종 출력 등을 명확한 키(key)로 구분하여 그래프의 로직을
단순하고 유지보수하기 쉽게 만듭니다.^4^ 반면, 체계 없이 설계된 상태는
노드 함수의 복잡도를 높이고 시스템 전체를 취약하게 만듭니다. 따라서
LangGraph 에이전트 개발의 첫 단계이자 가장 중요한 단계는 바로 상태
스키마를 아키텍처 관점에서 설계하는 것입니다.

가장 기본적인 챗봇의 상태는 대화 기록을 저장하는 messages 키 하나만 가질
수 있습니다. 이때 Annotated와 add_messages 함수를 사용하여 새로운
메시지가 기존 리스트를 덮어쓰는 대신 추가되도록 정의합니다.^1^

> Python

from typing import Annotated, TypedDict  
from langgraph.graph.message import add_messages  
  
class BasicChatState(TypedDict):  
\# add_messages는 상태 업데이트 시 메시지 리스트에 새로운 메시지를
추가하는 리듀서 함수입니다.  
messages: Annotated\[list, add_messages\]

더 복잡한 멀티 에이전트 시스템에서는 상태가 훨씬 더 정교해집니다. 예를
들어, 도구 호출 결과, 오류 발생 횟수, 작업 계획, 하위 에이전트의 결과
등을 저장하기 위한 별도의 키를 포함할 수 있습니다.^4^

> Python

from typing import List, Dict, Optional, TypedDict  
import operator  
  
class AgentState(TypedDict):  
input: str  
chat_history: Annotated\[list, operator.add\]  
agent_outcome: Optional\[str\]  
tool_outputs: Optional  
error: str  
error_count: int

여기서 operator.add와 같은 \*\*상태 리듀서(State Reducer)\*\*는 주목할
만한 개념입니다. 리듀서는 특정 상태 키가 어떻게 업데이트될지를 정의하는
함수입니다. add_messages나 operator.add는 리스트에 요소를 추가하는 반면,
리듀서가 지정되지 않은 키는 새로운 값으로 덮어쓰기(overwrite)됩니다.^1^
이 미묘한 차이를 이해하는 것은 대화 기록을 누적하거나 여러 에이전트의
결과를 수집하는 등, 상태를 올바르게 관리하는 데 매우 중요합니다.

### **1.3. 노드와 엣지: 계산 및 제어 흐름 프리미티브 정의** {#노드와-엣지-계산-및-제어-흐름-프리미티브-정의}

StateGraph는 노드(Nodes)와 엣지(Edges)라는 두 가지 핵심 프리미티브를
통해 구성됩니다.

\*\*노드(Nodes)\*\*는 그래프 내에서 \"실행자(doers)\"의 역할을 합니다.
각 노드는 현재 State 객체를 입력으로 받는 Python 함수 또는 LangChain
실행 가능 객체(Runnable)입니다. 노드는 입력을 바탕으로 특정 계산을
수행하고(예: LLM 호출, 도구 실행, 데이터베이스 조회), 그 결과를 State
객체를 업데이트할 정보가 담긴 딕셔너리 형태로 반환합니다.^1^ 노드가
반환한 딕셔너리의 키-값 쌍은

StateGraph에 의해 기존 상태에 병합(merge)됩니다.

\*\*엣지(Edges)\*\*는 \"결정자(deciders)\"의 역할을 합니다. 엣지는
노드들을 연결하여 제어의 흐름을 정의합니다. 한 노드의 실행이 완료된 후,
엣지는 업데이트된 상태를 다음에 어떤 노드로 전달할지 결정합니다.
LangGraph에는 두 가지 주요 엣지 유형이 있습니다:

1.  **일반 엣지 (Direct Edges):** add_edge() 메서드를 사용하여 정의되며,
    > 한 노드에서 다른 노드로의 무조건적인 전환을 나타냅니다. 예를 들어,
    > workflow.add_edge(\"agent\", \"tool_executor\")는 agent 노드가
    > 끝나면 항상 tool_executor 노드로 이동하라는 의미입니다.^3^

2.  **조건부 엣지 (Conditional Edges):** add_conditional_edges()
    > 메서드를 사용하여 정의되며, LangGraph의 동적 라우팅 기능을
    > 구현하는 핵심 메커니즘입니다. 이 엣지는 특정 노드(소스 노드)와
    > 함께, 상태를 평가하여 다음 노드를 결정하는 \'조건 함수\'를 인자로
    > 받습니다. 이 조건 함수는 현재 State를 검사하여 다음에 실행할
    > 노드의 이름을 문자열로 반환합니다. 이를 통해 \"만약 A 조건이면 B
    > 노드로, C 조건이면 D 노드로 가라\"와 같은 복잡한 분기 로직을
    > 구현할 수 있습니다.^3^

모든 StateGraph는 명시적인 진입점(Entry Point)과 최소 하나 이상의
종료점(End Point)을 가져야 합니다. 진입점은 set_entry_point() 메서드나
특별한 START 노드에서 엣지를 연결하여 정의할 수 있습니다. 종료점은
END라는 특별한 노드로 엣지를 연결하여 워크플로우의 끝을 알립니다.^3^
이러한 구조적 요구사항은 그래프가 항상 예측 가능한 방식으로 시작하고
종료되도록 보장합니다.

## **2. 동적 및 상호작용 에이전트를 위한 핵심 메커니즘** {#동적-및-상호작용-에이전트를-위한-핵심-메커니즘}

그래프의 정적 구조를 이해했다면, 다음 단계는 에이전트에게 지능적이고
상호작용적인 능력을 부여하는 동적 메커니즘을 파악하는 것입니다. 이
섹션에서는 조건부 엣지를 통한 지능형 라우팅, 도구 호출을 통한 외부 기능
활용, 그리고 메모리 아키텍처를 통한 대화의 연속성 확보 방법을 심도 있게
다룹니다.

### **2.1. 조건부 엣지: 지능형 상태 기반 라우팅 구현** {#조건부-엣지-지능형-상태-기반-라우팅-구현}

조건부 엣지는 LangGraph의 \"if-else\" 문과 같으며, 애플리케이션의 현재
상태에 따라 워크플로우를 동적으로 분기시키는 핵심적인 제어
장치입니다.^3^ 에이전트가 스스로 판단하여 다음 행동을 결정하는 모든
지능적인 행동은 이 조건부 엣지를 통해 구현됩니다. 에이전트적 루프, 오류
처리, 사용자 의도에 따른 작업 분기 등이 모두 여기에 해당합니다.

조건부 엣지를 구현하기 위해서는 먼저 \'라우팅 함수\'를 정의해야 합니다.
이 함수는 현재 State를 인자로 받아, 다음에 실행될 노드의 이름을 나타내는
문자열을 반환합니다. 이 반환된 문자열은 add_conditional_edges 메서드에
전달된 매핑 딕셔너리의 키와 일치해야 합니다.^3^

**주요 활용 사례:**

- **도구 호출 루프(Tool-Calling Loops):** 에이전트의 가장 일반적인
  > 패턴은 LLM의 응답을 분석하여 도구 사용 여부를 결정하는 것입니다.
  > 라우팅 함수는 마지막 메시지에 tool_calls 속성이 있는지 확인합니다.
  > 만약 존재한다면 \'tool_executor\' 노드로, 그렇지 않다면 최종 응답을
  > 생성하거나 대화를 종료하는 \'END\'로 라우팅합니다.^7^ 이 단순한
  > 패턴이 바로 ReAct(Reason+Act)와 같은 에이전트 패러다임의 근간을
  > 이룹니다. ReAct는 LangGraph의 특별한 기능이 아니라, 상태와 조건부
  > 엣지라는 기본 프리미티브로 구현된 하나의 제어 흐름 패턴에
  > 불과합니다.^17^ 이는 개발자가 단순한 ReAct를 넘어, 여러 도구 실행
  > 노드나 검증, 성찰 단계를 포함하는 훨씬 더 복잡한 루프를 자유롭게
  > 설계할 수 있음을 의미합니다.  
  > Python  
  > from langgraph.graph import StateGraph, END  
  > from typing import Literal  
  >   
  > def should_call_tools(state: AgentState) -\> Literal\[\"tools\",
  > \"\_\_end\_\_\"\]:  
  > \# 마지막 메시지에 tool_calls가 있는지 검사  
  > if \"tool_calls\" in
  > state\[\"messages\"\]\[-1\].additional_kwargs:  
  > return \"tools\"  
  > return \"\_\_end\_\_\"  
  >   
  > workflow = StateGraph(AgentState)  
  > \#\... 노드 추가\...  
  > workflow.add_conditional_edges(  
  > \"agent\", \# 소스 노드  
  > should_call_tools, \# 라우팅 함수  
  > {  
  > \"tools\": \"tool_executor\", \# \'tools\'를 반환하면 tool_executor
  > 노드로 이동  
  > \"\_\_end\_\_\": END \# \'\_\_end\_\_\'를 반환하면 그래프 종료  
  > }  
  > )

- **오류 처리 및 재시도(Error Handling & Retries):** 견고한 시스템은
  > 실패를 예측하고 대응할 수 있어야 합니다. 라우팅 함수는 상태 내의
  > error 플래그나 error_count를 확인하여, 오류 발생 시 retry_handler
  > 노드나 error_handler 노드로 제어를 넘길 수 있습니다. 이를 통해 특정
  > 횟수만큼 재시도하거나 사용자에게 오류를 알리는 등의 로직을 구현할 수
  > 있습니다.^10^

- **사용자 질의 분류(Query Classification):** 챗봇이 여러 기능을 제공할
  > 때, 초기 노드에서 사용자의 질의를 분석하고 그 의도를 분류(예: \'일반
  > 대화\', \'정보 검색\', \'데이터 분석\')하여 상태의 query_type 필드를
  > 업데이트할 수 있습니다. 그 후 조건부 엣지는 이 query_type에 따라
  > 각각의 전문 에이전트 노드(예: general_chat_node, web_search_node,
  > data_analysis_node)로 작업을 분기합니다.^19^

### **2.2. 도구 호출: 에이전트에게 외부 기능 부여하기** {#도구-호출-에이전트에게-외부-기능-부여하기}

에이전트가 단순히 대화만 하는 것을 넘어 실질적인 가치를 창출하려면 외부
세계와 상호작용할 수 있어야 합니다. 도구 호출(Tool Calling)은 LLM이 외부
API, 데이터베이스, 계산기 등과 같은 외부 함수를 호출할 수 있도록 하는
메커니즘입니다.^20^ LangGraph는 이 과정을 체계적으로 지원합니다.

1.  **도구 생성(Creation):** Python 함수를 정의하고 @tool 데코레이터를
    > 붙여 LangChain 도구로 만듭니다. 이 데코레이터는 함수의 이름,
    > 설명(docstring), 그리고 인자들의 타입을 분석하여 LLM이 이해할 수
    > 있는 스키마를 자동으로 생성합니다. LLM은 이 스키마, 특히 상세한
    > 설명을 보고 언제, 어떻게 이 도구를 사용해야 할지 판단하므로,
    > 설명은 최대한 명확하고 자세하게 작성해야 합니다.^1^

2.  **도구 바인딩(Binding):** 생성된 도구들을 리스트로 묶어,
    > bind_tools() 메서드를 통해 LLM에 연결합니다. 이 과정을 통해 LLM은
    > 자신이 사용할 수 있는 도구들의 목록과 사용법을 인지하게 됩니다.
    > 사용자의 요청이 특정 도구의 기능과 관련이 있다고 판단되면, LLM은
    > 일반적인 텍스트 응답 대신 해당 도구를 호출하라는 지시(JSON 형식의
    > tool_calls 객체)를 생성합니다.^20^

3.  **도구 실행(Execution):** LangGraph는 ToolNode라는 사전 구축된
    > 유틸리티 노드를 제공합니다. 이 노드는 LLM으로부터 tool_calls가
    > 포함된 AIMessage를 받아, 명시된 도구들을 자동으로 실행하고, 그
    > 결과를 ToolMessage 형태로 변환하여 상태에 추가해줍니다.^15^  
    > ToolNode는 순차적인 도구 호출뿐만 아니라, 하나의 LLM 응답에 여러
    > 개의 도구 호출이 포함된 경우 이를 **병렬로 실행**하는 고급 기능도
    > 지원합니다. 이는 여러 데이터 소스를 동시에 조회해야 하는 복잡한
    > 질의에서 응답 시간을 획기적으로 단축시킬 수 있습니다.^10^

ToolNode의 존재는 LangGraph의 설계 철학을 명확히 보여줍니다. 개발자가
도구 호출 결과를 파싱하고, 각 함수를 실행하고, 결과를 다시 메시지 형태로
포맷팅하는 등의 상투적인 오케스트레이션 코드를 작성하는 대신,
ToolNode라는 고수준의 추상화된 컴포넌트를 사용하여 복잡한 병렬 실행
패턴을 손쉽게 구현할 수 있도록 돕습니다. 이를 통해 개발자는 에이전트의
고유한 핵심 로직에 더 집중할 수 있습니다.

### **2.3. 대화 메모리 아키텍처: 다중 턴 상호작용을 위한 상태 지속** {#대화-메모리-아키텍처-다중-턴-상호작용을-위한-상태-지속}

단발성 질의응답을 넘어 사용자와 의미 있는 대화를 이어가기 위해
에이전트는 이전 상호작용을 기억해야 합니다. LangGraph는
\*\*체크포인터(Checkpointer)\*\*라는 강력한 메커니즘을 통해 메모리를
관리합니다. 체크포인터는 그래프의 State를 지정된 백엔드(예: 인메모리,
SQLite, Postgres)에 자동으로 저장하고 불러오는 역할을 합니다.^2^

메모리는 그 범위와 목적에 따라 단기 메모리와 장기 메모리로 나눌 수
있으며, 이 둘은 서로 다른 아키텍처적 접근을 요구합니다.

- **단기 메모리 (대화 스레드 범위):** 단일 대화 세션 내에서의 맥락
  > 유지를 의미합니다. LangGraph에서는 각 대화를 고유한 thread_id와
  > 연결하여 이 문제를 매우 간단하게 해결합니다. 그래프를 실행할 때
  > RunnableConfig 객체에 {\"configurable\": {\"thread_id\":
  > \"some-unique-id\"}}와 같이 thread_id를 지정하면, 체크포인터가 해당
  > ID에 대한 MessagesState를 자동으로 저장하고 다음 호출 시 불러옵니다.
  > 이를 통해 개발자는 별도의 코드 없이도 완벽한 대화 기록 유지를 구현할
  > 수 있습니다.^7^

- **장기 메모리 (세션 초월):** 에이전트가 여러 대화에 걸쳐 사용자의
  > 이름, 선호도, 과거 요청 등을 기억하게 하려면 더 정교한 접근이
  > 필요합니다. 체크포인터가 지속성을 위한 *메커니즘*을 제공한다면, 장기
  > 메모리는 에이전트가 직접 관리해야 하는 *지능적 능력*입니다. 이는
  > 메모리 관리가 \'켜고 끄는\' 기능이 아니라, 에이전트의 핵심 로직의
  > 일부로 설계되어야 함을 의미합니다.^25^  
  > 구체적인 구현은 다음과 같은 구성요소를 포함합니다:

  1.  **메모리 도구(Memory Tools):** 에이전트에게 save_memory(fact:
      > str)나 search_memory(query: str)와 같은 도구를 제공합니다.
      > 에이전트는 대화 중 중요하다고 판단되는 정보를 이 도구들을 사용해
      > 영구적인 벡터 저장소(Vector Store)에 저장하거나, 필요할 때 관련
      > 기억을 검색할 수 있습니다.^26^

  2.  **메모리 로딩 노드(Memory Loading Node):** 그래프의 시작 부분에
      > load_memories와 같은 전용 노드를 추가합니다. 이 노드는 본격적인
      > 에이전트 로직이 실행되기 전에 현재 대화 내용과 관련된 장기
      > 기억들을 벡터 저장소에서 검색하여, 이를 현재 State에 주입하는
      > 역할을 합니다. 주입된 기억은 LLM 프롬프트의 일부가 되어
      > 에이전트가 더 개인화되고 맥락에 맞는 응답을 생성하도록
      > 돕습니다.^27^

결론적으로, 메모리는 단순히 켜는 기능이 아니라, 에이전트가 스스로
무엇을, 언제, 어떻게 기억하고 사용할지 결정하는 능동적인 프로세스로
설계되어야 합니다. 이는 에이전트의 프롬프트, 도구, 그리고 그래프 구조
전반에 걸쳐 체계적으로 구현되어야 하는 핵심적인 아키텍처 구성
요소입니다.

## **3. Supervisor-Worker 패턴: 핵심 멀티 에이전트 아키텍처** {#supervisor-worker-패턴-핵심-멀티-에이전트-아키텍처}

에이전트 시스템의 복잡성이 증가함에 따라, 단일 에이전트가 모든 작업을
처리하는 방식은 비효율적이 됩니다. 이를 해결하기 위한 가장 일반적이고
강력한 패턴이 바로 Supervisor-Worker 아키텍처입니다. 이 섹션에서는 여러
전문 에이전트를 효과적으로 조율하는 이 핵심 패턴을 상세히 분석합니다.

### **3.1. 개념적 프레임워크: 오케스트레이션, 전문화, 그리고 작업 위임** {#개념적-프레임워크-오케스트레이션-전문화-그리고-작업-위임}

- **핵심 문제:** 한 에이전트에게 너무 많은 도구나 책임이 주어지면, 어떤
  > 도구를 언제 사용해야 할지 혼란스러워하며 성능이 저하되는 문제가
  > 발생합니다.^28^ 이는 LLM의 제한된 컨텍스트 창과 추론 능력에서
  > 비롯되는 근본적인 한계입니다.

- **해결책:** 계층적 구조를 도입하여, 중앙의 **\"감독자(Supervisor)\"**
  > 에이전트가 오케스트레이터 역할을 수행하게 합니다. 감독자의 유일한
  > 임무는 사용자의 요청과 현재 대화의 맥락을 분석하여, 가장 적합한
  > **\"작업자(Worker)\"** 에이전트에게 작업을 위임하는 것입니다.^8^

- **장점:** 이 패턴은 시스템의 \*\*모듈성(Modularity),
  > 확장성(Scalability), 그리고 전문성(Specialization)\*\*을 크게
  > 향상시킵니다. 각 작업자 에이전트는 웹 검색, 데이터베이스 쿼리, 문서
  > 작성 등 좁은 범위의 특정 작업에만 집중하고 제한된 도구 세트를
  > 가지므로, 훨씬 더 안정적이고 효율적으로 작업을 수행할 수
  > 있습니다.^29^

### **3.2. 구현 심층 분석: LLM 기반 라우터로서의 감독자 구축** {#구현-심층-분석-llm-기반-라우터로서의-감독자-구축}

감독자 에이전트는 LangGraph 내에서 하나의 노드로 구현됩니다. 이 노드의
핵심 로직은 특정 시스템 프롬프트와 함께 LLM을 호출하는 것입니다.

- **감독자 프롬프트:** 이 시스템 프롬프트는 감독자 LLM에게 자신이 여러
  > 작업자를 관리하는 관리자(manager) 역할을 수행해야 함을 명시적으로
  > 지시합니다. 프롬프트에는 사용 가능한 작업자들의 목록과 각각의 전문
  > 분야, 그리고 어떤 상황에서 어떤 작업자에게 작업을 위임해야 하는지에
  > 대한 라우팅 규칙이 포함됩니다.^8^ 이 프롬프트는 단순한 지시를 넘어,
  > 전체 멀티 에이전트 시스템의 \'메타 인지(meta-cognition)\'
  > 계층으로서, 시스템의 고수준 운영 논리를 인코딩합니다. 이 프롬프트
  > 하나를 수정하는 것만으로 작업자 에이전트들의 코드를 전혀 건드리지
  > 않고도 전체 시스템의 동작 방식을 근본적으로 바꿀 수 있습니다.

- **구조화된 출력(Structured Output):** 감독자 LLM이 \'웹 연구원에게
  > 작업을 넘기세요\'와 같은 모호한 텍스트 대신, {\"next\":
  > \"web_researcher\"}나 \"FINISH\"와 같이 기계가 해석할 수 있는 명확한
  > 형식으로 응답하도록 강제하는 것이 중요합니다. 이는 LLM의 도구 호출
  > 기능이나 구조화된 출력 기능을 사용하여 구현할 수 있으며, 이를 통해
  > 라우팅 결정을 안정적으로 파싱할 수 있습니다.^29^

- **라우팅 로직:** 감독자 노드 다음에는 조건부 엣지가 연결됩니다. 이
  > 엣지의 라우팅 함수는 상태(State)에서 감독자의 결정(예:
  > state\[\'next_worker\'\])을 읽어와, 해당 작업자 노드로 제어를
  > 전달하거나, 감독자가 FINISH를 반환한 경우 END로 그래프를
  > 종료시킵니다.^8^

이러한 Supervisor-Worker 패턴이 매우 보편적이고 강력하기 때문에,
LangChain 팀은 이를 langgraph-supervisor라는 별도의 라이브러리로
추상화하여 제공합니다.^30^

create_supervisor와 같은 헬퍼 함수를 사용하면 단 몇 줄의 코드로 이
복잡한 아키텍처를 신속하게 구현할 수 있습니다.^30^ 이는 개발자가
일반적인 사용 사례를 위해 사전 패키징된 솔루션을 활용하면서도,
필요시에는 저수준 프리미티브를 사용하여 자신만의 맞춤형 솔루션을 구축할
수 있도록 하는 LangGraph의 설계 철학을 잘 보여줍니다.

### **3.3. 사례 연구: 전문 에이전트 팀 구성** {#사례-연구-전문-에이전트-팀-구성}

실제 Supervisor-Worker 시스템을 구축하기 위해, 다음과 같은 세 가지
구체적인 작업자 에이전트를 구현해 보겠습니다.

- **작업자 에이전트(Worker Agents):** 각 작업자는 create_react_agent와
  > 같은 헬퍼 함수를 사용하거나, 자체적인 하위 그래프(subgraph)로 구성된
  > 독립적인 에이전트입니다.^29^

  1.  **웹 리서치 에이전트 (Web Research Agent):** Tavily, SerpAPI 등과
      > 같은 웹 검색 도구를 장착하여 최신 정보를 인터넷에서 찾아오는
      > 역할을 합니다.^19^

  2.  **에이전틱 RAG 에이전트 (Agentic RAG Agent):** 특정 문서나
      > 데이터베이스에 대한 지식을 가진 검색기(retriever) 도구를
      > 사용하여, 내부 지식 기반으로부터 정보를 조회합니다.^29^

  3.  **NL2SQL 에이전트 (NL2SQL Agent):** 자연어 질의를 SQL 쿼리로
      > 변환하여 데이터베이스를 조회하는 도구를 가집니다.^17^

- **작업자 노드 구현:** 각 작업자 에이전트는 그래프 내에서 하나의 노드
  > 함수로 래핑(wrapping)됩니다. 이 함수는 현재 상태를 받아 해당
  > 에이전트를 실행하고, 에이전트의 최종 응답을 특정 name을 가진
  > HumanMessage로 포맷팅하여 상태에 추가합니다 (예:
  > HumanMessage(content=\..., name=\"web_researcher\")). 이 name 태그는
  > 감독자가 대화 기록에서 어떤 작업자가 어떤 응답을 했는지 명확하게
  > 구분하는 데 결정적인 역할을 합니다.^29^

### **3.4. 그래프 구성 및 상태 전환 분석** {#그래프-구성-및-상태-전환-분석}

이제 모든 구성요소를 결합하여 완전한 감독자 그래프를 구축합니다.

- **그래프 구성:**

  1.  START 노드는 supervisor 노드로 직접 연결됩니다.

  2.  supervisor 노드 다음에는 조건부 엣지가 위치하며, 이 엣지는
      > 감독자의 라우팅 결정에 따라 모든 작업자 노드(web_research_node,
      > rag_node 등) 또는 END로 분기됩니다.

  3.  모든 작업자 노드의 실행이 끝나면, 엣지는 다시 supervisor 노드로
      > 제어를 반환합니다.

> 이 구조는 **Supervisor -\> Worker -\> Supervisor** 라는 핵심적인 중앙
> 루프를 형성합니다.^29^

- **상태 흐름 추적:** \"FutureSmart AI의 창업자를 찾고, 그에 대한 웹
  > 리서치를 수행하라\"와 같은 복합적인 질의가 어떻게 처리되는지 상태의
  > 흐름을 따라가 보겠습니다.^29^

  1.  **초기 상태:** messages 리스트에 사용자의 초기 질의가 담긴 상태로
      > 시작합니다.

  2.  **1차 라우팅:** supervisor 노드가 실행됩니다. LLM은 \"창업자를
      > 찾아라\"라는 부분을 보고, 내부 지식 검색이 적합하다고 판단하여
      > rag_agent로 작업을 위임합니다.

  3.  **RAG 에이전트 실행:** rag_node가 실행됩니다. rag_agent는 내부
      > 문서를 검색하여 \"Pradip Nichite\"라는 창업자 이름을 찾아냅니다.
      > 이 결과는 name=\"rag_agent\" 태그와 함께 messages 리스트에
      > 추가됩니다.

  4.  **2차 라우팅:** 제어가 다시 supervisor 노드로 돌아옵니다. 이제
      > 감독자는 사용자의 초기 질의뿐만 아니라 RAG 에이전트의
      > 결과(\"Pradip Nichite\")까지 모두 볼 수 있습니다. 이를 바탕으로
      > \"그에 대한 웹 리서치를 수행하라\"는 다음 작업을 처리하기 위해
      > web_researcher에게 작업을 위임합니다.

  5.  **웹 리서치 에이전트 실행:** web_research_node가 실행됩니다.
      > web_researcher는 \"Pradip Nichite\"에 대한 웹 검색을 수행하고,
      > 그의 경력과 활동에 대한 정보를 찾아 name=\"web_researcher\"
      > 태그와 함께 messages에 추가합니다.

  6.  **최종 결정:** 제어가 다시 supervisor에게 돌아옵니다. 이제
      > 감독자는 창업자 정보와 웹 리서치 결과를 모두 가지고 있으므로, 더
      > 이상 필요한 작업이 없다고 판단합니다. LLM에게 FINISH를 지시하고,
      > 모든 정보를 종합하여 사용자에게 최종적인 답변을 생성한 후 END로
      > 그래프를 종료합니다.

이처럼 Supervisor-Worker 패턴은 복잡한 다단계 작업을 여러 전문 에이전트
간의 체계적인 협업을 통해 해결하는 강력하고 유연한 아키텍처를
제공합니다.

## **4. 고급 아키텍처: 확장 가능한 복잡성을 위한 계층적 에이전트 팀** {#고급-아키텍처-확장-가능한-복잡성을-위한-계층적-에이전트-팀}

단일 감독자(Supervisor) 모델은 많은 멀티 에이전트 시나리오에서
효과적이지만, 시스템의 복잡성이 특정 임계점을 넘어서면 한계에
부딪힙니다. 작업자의 수가 너무 많아지거나, 단일 작업자가 수행해야 할
일이 그 자체로 복잡한 다단계 프로세스일 경우, 감독자 노드가 병목 현상을
일으킬 수 있습니다.^34^ 이러한 문제를 해결하기 위해 LangGraph는 더욱
확장 가능하고 모듈화된

**계층적 에이전트 팀(Hierarchical Agent Teams)** 아키텍처를 제안합니다.

### **4.1. 계층 구조의 합리성: 모듈성과 제어를 위한 하위 그래프 구성** {#계층-구조의-합리성-모듈성과-제어를-위한-하위-그래프-구성}

계층적 에이전트 팀의 핵심 아이디어는 Supervisor-Worker 패턴을 재귀적으로
적용하는 것입니다. 즉, 전체 에이전트 팀(각각의 \"중간 관리자급\"
감독자와 작업자들로 구성된)을 하나의 노드, 즉 \*\*하위
그래프(subgraph)\*\*로 취급하고, 이 하위 그래프들을 조율하는
**\"최상위\" 감독자**를 두는 것입니다.^2^ 이는 마치 기업에서 최고
경영자(최상위 감독자)가 각 부서장(중간 관리자급 감독자)에게 업무를
위임하고, 부서장은 다시 팀원(작업자)들을 관리하여 과업을 수행하는 것과
같은 \"팀의 팀(team of teams)\" 구조를 형성합니다.^8^

예를 들어, \"AI 기술의 최신 동향에 대한 연구 보고서를 작성하라\"는
복잡한 요청이 들어왔다고 가정해 봅시다. 최상위 \"리서치 어시스턴트\"
감독자는 이 작업을 \"웹 리서치 팀\"과 \"문서 작성 팀\"이라는 두 개의
전문 팀에게 순차적으로 위임할 수 있습니다. 먼저 \"웹 리서치 팀\"의
감독자가 자신의 팀원들(예: search_agent, scraper_agent)을 조율하여
필요한 정보를 수집하고 요약합니다. 이 결과물이 최상위 감독자에게
보고되면, 그는 이 요약본을 \"문서 작성 팀\"에게 전달합니다. 그러면
\"문서 작성 팀\"의 감독자가 자신의 팀원들(예: outline_agent,
writer_agent, editor_agent)을 지휘하여 실제 보고서를 작성하게
됩니다.^35^

이러한 계층적 접근 방식은 다음과 같은 명백한 이점을 가집니다.

- **복잡성 관리:** 거대한 단일 그래프 대신, 작고 응집력 있으며
  > 독립적으로 테스트 가능한 여러 개의 하위 그래프로 시스템을 분해하여
  > 관리 복잡성을 크게 낮춥니다.

- **재사용성:** 잘 정의된 기능을 수행하는 에이전트 팀(하위 그래프)은
  > 다른 프로젝트나 워크플로우에서 재사용될 수 있는 모듈식 컴포넌트가
  > 됩니다.

- **확장성:** 새로운 기능이 필요할 때, 기존 시스템을 수정하는 대신
  > 새로운 전문 팀(하위 그래프)을 추가하고 최상위 감독자의 라우팅 규칙만
  > 업데이트하면 되므로 시스템 확장이 용이합니다.

이 구조는 본질적으로 프랙탈(fractal) 패턴을 보입니다. 최상위 그래프의
구조(감독자, 조건부 엣지, 작업자 노드)와 각 팀 하위 그래프의 구조가
동일하기 때문입니다. 유일한 차이점은 최상위 그래프의 \"작업자\"가 개별
에이전트가 아니라 완전한 그래프라는 점입니다. 이는 이론적으로 얼마든지
깊은 계층 구조를 구축할 수 있음을 의미하며, 이는 매우 복잡한 AI 시스템을
설계할 수 있는 강력한 확장성을 제공합니다.

### **4.2. 구현 심층 분석: 독립적인 에이전트 팀을 하위 그래프로 생성하기** {#구현-심층-분석-독립적인-에이전트-팀을-하위-그래프로-생성하기}

계층 구조의 각 팀은 그 자체로 완전하고 컴파일 가능한 StateGraph로
만들어집니다.^35^ 즉, 3장에서 다룬 Supervisor-Worker 패턴을 사용하여 각
팀을 독립적인 하위 애플리케이션으로 구축합니다.

1\. 리서치 팀 (Research Team) 하위 그래프:

이 팀은 웹 검색과 스크래핑을 전문으로 합니다.

> Python

from langgraph.graph import StateGraph, START  
from langchain_openai import ChatOpenAI  
\#\... (이전 섹션의 search_node, web_scraper_node, make_supervisor_node
등 헬퍼 함수 정의)  
  
\# 리서치 팀의 작업자 목록  
research_members = \[\"search\", \"web_scraper\"\]  
\# 리서치 팀을 위한 중간 관리자급 감독자 노드 생성  
research_supervisor_node = make_supervisor_node(llm, research_members)  
  
\# 리서치 팀 그래프 빌더 초기화  
research_builder = StateGraph(State) \# State는 적절히 정의된
TypedDict  
research_builder.add_node(\"supervisor\", research_supervisor_node)  
research_builder.add_node(\"search\", search_node)  
research_builder.add_node(\"web_scraper\", web_scraper_node)  
  
\# 리서치 팀 그래프의 엣지 정의  
research_builder.add_edge(START, \"supervisor\")  
research_builder.add_conditional_edges(  
\"supervisor\",  
lambda state: state\[\"next\"\], \# \'next\'는 감독자 노드가 상태에
업데이트한 값  
{member: member for member in research_members}  
)  
for member in research_members:  
research_builder.add_edge(member, \"supervisor\")  
  
\# 리서치 팀 그래프 컴파일  
research_graph = research_builder.compile()

^35^

2\. 문서 작성 팀 (Document Writing Team) 하위 그래프:

이 팀은 개요 작성, 본문 작성, 차트 생성 등을 담당합니다.

> Python

\# 문서 작성 팀의 작업자 목록  
writing_members = \[\"doc_writer\", \"note_taker\",
\"chart_generator\"\]  
\# 문서 작성 팀을 위한 감독자 노드  
doc_writing_supervisor_node = make_supervisor_node(llm,
writing_members)  
  
\# 문서 작성 팀 그래프 빌더 초기화  
writing_builder = StateGraph(State)  
writing_builder.add_node(\"supervisor\", doc_writing_supervisor_node)  
writing_builder.add_node(\"doc_writer\", doc_writing_node)  
writing_builder.add_node(\"note_taker\", note_taking_node)  
writing_builder.add_node(\"chart_generator\", chart_generating_node)  
  
\# 문서 작성 팀 그래프의 엣지 정의  
writing_builder.add_edge(START, \"supervisor\")  
writing_builder.add_conditional_edges(  
\"supervisor\",  
lambda state: state\[\"next\"\],  
{member: member for member in writing_members}  
)  
for member in writing_members:  
writing_builder.add_edge(member, \"supervisor\")  
  
\# 문서 작성 팀 그래프 컴파일  
writing_graph = writing_builder.compile()

^35^

### **4.3. 최상위 감독자: 팀 간의 협업 조율** {#최상위-감독자-팀-간의-협업-조율}

이제 독립적으로 작동하는 두 개의 팀(하위 그래프)이 준비되었습니다. 다음
단계는 이 팀들을 조율할 최상위 감독자 그래프를 만드는 것입니다.

- **핵심 개념:** 최상위 그래프는 컴파일된 팀 하위 그래프(research_graph,
  > writing_graph)를 마치 개별 도구나 노드처럼 취급합니다.

- **구현:**

  1.  **최상위 감독자 노드 생성:** 최상위 감독자의 프롬프트는 개별
      > 작업자가 아닌 \'팀\'에게 작업을 위임하도록 지시합니다 (예:
      > \"다음 작업은 research_team 또는 writing_team 중 누가 맡아야
      > 하는가?\").

  2.  **래퍼 노드(Wrapper Nodes) 생성:** 각 하위 그래프를 호출하기 위한
      > \'래퍼\' 노드를 만듭니다. 이 노드의 역할은 최상위
      > 상태(state)에서 필요한 정보를 추출하여 하위 그래프를
      > 실행(research_graph.invoke(\...))하고, 하위 그래프가 반환한 최종
      > 결과를 다시 최상위 상태 형식에 맞게 포맷팅하여 업데이트하는
      > 것입니다.

> Python

\# 최상위 감독자가 관리할 팀 목록  
top_level_members = \[\"research_team\", \"writing_team\"\]  
\# 최상위 감독자 노드 생성  
teams_supervisor_node = make_supervisor_node(llm, top_level_members)  
  
\# 하위 그래프를 호출하는 래퍼 노드 정의  
def call_research_team(state: State):  
\# 하위 그래프는 마지막 메시지를 입력으로 받도록 단순화  
result = research_graph.invoke({\"messages\":
\[state\[\"messages\"\]\[-1\]\]})  
\# 결과를 HumanMessage로 포맷팅하여 최상위 상태에 추가  
return {\"messages\":
\[HumanMessage(content=result\[\"messages\"\]\[-1\].content,
name=\"research_team\")\]}  
  
def call_writing_team(state: State):  
result = writing_graph.invoke({\"messages\":
\[state\[\"messages\"\]\[-1\]\]})  
return {\"messages\":
\[HumanMessage(content=result\[\"messages\"\]\[-1\].content,
name=\"writing_team\")\]}  
  
\# 최상위 그래프 빌더 초기화  
super_builder = StateGraph(State)  
super_builder.add_node(\"supervisor\", teams_supervisor_node)  
super_builder.add_node(\"research_team\", call_research_team)  
super_builder.add_node(\"writing_team\", call_writing_team)  
  
\# 최상위 그래프 엣지 정의  
super_builder.add_edge(START, \"supervisor\")  
super_builder.add_conditional_edges(  
\"supervisor\",  
lambda state: state\[\"next\"\],  
{\"research_team\": \"research_team\", \"writing_team\":
\"writing_team\", \"FINISH\": END}  
)  
super_builder.add_edge(\"research_team\", \"supervisor\")  
super_builder.add_edge(\"writing_team\", \"supervisor\")  
  
\# 최상위 그래프 컴파일  
super_graph = super_builder.compile()

^35^

### **4.4. 계층 간 상태 및 데이터 흐름 관리** {#계층-간-상태-및-데이터-흐름-관리}

계층적 아키텍처에서 가장 중요한 설계 결정 중 하나는 상태를 어떻게 관리할
것인가입니다.^28^

- **공유 상태 (Shared State):** 가장 간단한 방법은 모든 하위 그래프가
  > 부모 그래프와 동일한 상태 스키마를 공유하는 것입니다. 이 경우 래퍼
  > 노드는 단순히 상태 객체의 일부를 하위 그래프에 전달하기만 하면
  > 됩니다. 구현은 쉽지만, 팀이 많아질수록 상태 객체가 비대해지고
  > 복잡해져서 관리하기 어려워질 수 있습니다.

- **고립된 상태 (Isolated State):** 더 견고하고 모듈화된 접근 방식은 각
  > 하위 그래프가 자신만의 고유한 상태 스키마를 갖도록 하는 것입니다. 이
  > 경우, 부모 그래프와 하위 그래프 간에 데이터를 주고받기 위해 명시적인
  > 입력/출력 변환 로직이 필요합니다. 예를 들어, 최상위 상태의
  > task_description을 리서치 팀 상태의 research_topic으로 매핑해주는
  > 식입니다. 이는 초기 구현 복잡도를 높이지만, 각 팀의 독립성을
  > 보장하고 상태 충돌을 방지하여 장기적으로는 더 유지보수하기 쉬운
  > 시스템을 만듭니다.^28^

아래 표는 주요 멀티 에이전트 아키텍처를 비교하고, 이어지는 표는 계층적
시스템을 위한 상태 스키마 설계의 구체적인 예를 보여줍니다.

**표 1: LangGraph 멀티 에이전트 아키텍처 비교**

| 건축 패턴              | 제어 흐름                            | 주요 LangGraph 구성 요소                | 확장성 | 주요 사용 사례                         |
|------------------------|--------------------------------------|-----------------------------------------|--------|----------------------------------------|
| **ReAct 에이전트**     | 단일 에이전트 내의 순환 루프         | agent 노드, ToolNode, 조건부 엣지       | 낮음   | 단일 목표를 위한 순차적 도구 사용      |
| **Supervisor-Worker**  | 중앙 집중식 루프 (감독자 -\> 작업자) | 감독자 노드, 작업자 노드, 조건부 엣지   | 중간   | 여러 전문 분야에 걸친 작업 라우팅      |
| **계층적 에이전트 팀** | 계층적 위임 (상위 감독자 -\> 팀)     | 컴포지션된 하위 그래프, 래퍼 노드       | 높음   | 복잡한 프로젝트 자동화, 대규모 시스템  |
| **Plan-and-Execute**   | 선형 계획, 순차적 실행               | 플래너 노드, 실행자 노드, 리플래너 노드 | 중간   | 다단계 추론, 명확한 계획이 필요한 작업 |

**표 2: 리서치 어시스턴트를 위한 계층적 상태 스키마 예시**

> Python

from typing import TypedDict, List, Literal, Annotated  
from langgraph.graph.message import add_messages  
  
\# 리서치 팀의 고립된 상태 스키마  
class ResearchTeamState(TypedDict):  
topic: str  
search_queries: List\[str\]  
scraped_data: List\[str\]  
summary: str  
messages: Annotated\[List, add_messages\]  
next: str  
  
\# 문서 작성 팀의 고립된 상태 스키마  
class WritingTeamState(TypedDict):  
input_summary: str  
outline: str  
draft_content: str  
  
\# 최상위 그래프의 상태 스키마  
class TopLevelState(TypedDict):  
\# 전체 작업 상태  
messages: Annotated\[List, add_messages\]  
original_request: str  
final_answer: str  
  
\# 하위 그래프로 전달될 데이터  
\# 이 필드들은 래퍼 노드에서 하위 그래프의 상태로 매핑됨  
research_input: str  
writing_input: str  
  
\# 최상위 감독자의 제어 흐름 상태  
next_team: Literal

이러한 계층적 설계는 복잡한 AI 시스템을 작고 관리 가능한 단위로 분해하여
구축할 수 있는 강력한 프레임워크를 제공하며, 이는 미래의 자율 에이전트
시스템 개발에 핵심적인 역할을 할 것입니다.

## **5. 응용 에이전트 청사진 및 설계 패턴** {#응용-에이전트-청사진-및-설계-패턴}

지금까지 논의된 기본 원리와 아키텍처를 바탕으로, 실제 문제 해결에 적용할
수 있는 완전한 형태의 에이전트 청사진(blueprint)을 분석합니다. 이
섹션에서는 Plan-and-Execute 모델, 에이전틱 RAG 시스템, 그리고 여행 계획
어시스턴트와 같은 구체적인 설계 패턴을 통해 이론을 실제 구현으로
연결합니다.

### **5.1. Plan-and-Execute 모델: 추론과 실행의 분리** {#plan-and-execute-모델-추론과-실행의-분리}

단일 ReAct 루프는 모든 단계에서 LLM의 추론을 요구하기 때문에 비효율적일
수 있습니다. Plan-and-Execute 모델은 이 문제를 해결하기 위해
워크플로우를 두 개의 명확한 단계로 분리합니다.^18^

- **핵심 개념:**

  1.  **계획자(Planner):** 사용자의 고수준 목표를 입력받아, 이를
      > 달성하기 위한 다단계 계획을 생성하는 LLM입니다. 이 단계에서는
      > 실제 도구를 실행하지 않고 오직 계획 수립에만 집중합니다.^12^

  2.  **실행자(Executor):** 계획자가 수립한 계획을 입력받아, 각 단계를
      > 순차적으로 실행하는 에이전트입니다. 실행자는 현재 단계의
      > 작업에만 집중하므로 더 작고 빠른 LLM을 사용하거나, 심지어 LLM
      > 없이 결정적인 코드로 구현될 수도 있습니다.^18^

- **장점:** 이 접근 방식은 강력하고 비용이 많이 드는 \'계획자\' LLM의
  > 호출 횟수를 최소화하여 비용과 응답 시간을 줄입니다. 또한, LLM이 전체
  > 문제를 미리 \'생각\'하도록 강제함으로써 최종 결과물의 품질과
  > 신뢰성을 높이는 효과가 있습니다.^18^

- **구현:** LangGraph로 Plan-and-Execute 에이전트를 구현하려면 다음과
  > 같은 구성 요소가 필요합니다.

  - **PlanExecute 상태:** input, plan (계획 단계 리스트), past_steps
    > (완료된 단계와 결과), response 등을 포함하는 TypedDict 상태를
    > 정의합니다.^12^

  - **planner 노드:** 사용자의 입력을 받아 LLM을 호출하여 plan을
    > 생성하고 상태를 업데이트합니다.

  - **executor 노드:** plan에서 다음 단계를 가져와 실행하고, 그 결과를
    > past_steps에 추가합니다.

  - **replanner 노드:** 실행 결과를 바탕으로 계획을 수정하거나 새로운
    > 단계를 추가해야 할지 결정하는 노드입니다. 이 노드는 실행이 예상치
    > 못한 결과를 낳았을 때 시스템이 유연하게 대처할 수 있도록
    > 합니다.^12^

### **5.2. 청사진 분석: 완전한 에이전틱 RAG 시스템 구축** {#청사진-분석-완전한-에이전틱-rag-시스템-구축}

전통적인 RAG(Retrieval-Augmented Generation)는 \'검색 후 생성\'이라는
고정된 파이프라인을 따릅니다. 반면, \*\*에이전틱 RAG(Agentic RAG)\*\*는
RAG 프로세스 자체에 에이전트의 지능적인 의사결정을 도입하여 성능을
극대화하는 차세대 RAG 패러다임입니다.^40^

- **에이전트적 의사결정:**

  1.  **라우팅(Routing):** 사용자의 질문이 외부 지식 검색(retrieval)을
      > 필요로 하는지, 아니면 LLM의 내장 지식만으로 답변할 수 있는지
      > 에이전트가 먼저 판단합니다. 불필요한 검색을 생략하여 효율성을
      > 높입니다.^33^

  2.  **질의 변환(Query Transformation):** 사용자의 원본 질문이 검색에
      > 최적화되어 있지 않을 수 있습니다. 에이전트는 검색 성능을 높이기
      > 위해 질문을 더 명확하거나 구체적인 형태로 재작성(rewrite)할지
      > 결정할 수 있습니다.^33^

  3.  **문서 등급 평가(Document Grading):** 문서를 검색한 후, 에이전트는
      > 검색된 문서들이 실제로 질문과 관련이 있는지 \"등급\"을 매깁니다.
      > 관련성이 낮다고 판단되면, 해당 문서를 무시하고 질의를 재작성하여
      > 다시 검색하거나, 웹 검색과 같은 다른 도구로 대체(fallback)하는
      > 결정을 내릴 수 있습니다.^33^

- **그래프 구현:** 에이전틱 RAG 워크플로우는 LangGraph로 매우 효과적으로
  > 모델링할 수 있습니다. 그래프는 rewrite, retrieve, grade_documents,
  > generate 등의 노드들로 구성되며, 각 노드 사이는 에이전트의
  > 의사결정을 나타내는 조건부 엣지로 연결됩니다. 예를 들어,
  > grade_documents 노드 이후의 조건부 엣지는 평가 점수에 따라 generate
  > 노드로 바로 가거나, rewrite 노드로 돌아가 검색을 다시 시도하도록
  > 분기할 수 있습니다.^33^

이러한 에이전틱 패턴들은 서로 배타적인 것이 아니라, 조합
가능한(composable) 빌딩 블록이라는 점이 중요합니다. 예를 들어,
Plan-and-Execute 모델의 한 \'실행\' 단계가 전체 에이전틱 RAG 하위
그래프를 호출하는 식으로 매우 정교한 에이전트를 설계할 수 있습니다. 이는
에이전트 설계의 미래가 고도로 모듈화되고 유연한 방향으로 나아가고 있음을
시사합니다.

### **5.3. 청사진 분석: 멀티 에이전트 여행 계획 어시스턴트** {#청사진-분석-멀티-에이전트-여행-계획-어시스턴트}

이 청사진은 Supervisor-Worker 패턴과 다양한 도구를 결합하여 실용적인
대화형 어시스턴트를 만드는 방법을 보여줍니다.

- **아키텍처:**

  - **감독자 chatbot 에이전트:** 사용자와의 주된 상호작용을 담당하며,
    > 요청을 분석하여 적절한 작업자 에이전트에게 작업을 위임합니다.

  - **itinerary_agent (일정 계획 에이전트):** 사용자의 선호도(여행 기간,
    > 관심사, 예산 등)를 바탕으로 상세한 여행 일정을 생성하는
    > 작업자입니다.

  - **flight_agent (항공편 조회 에이전트):** 외부 항공편 검색 API를
    > 호출하는 도구를 가진 ReAct 스타일의 작업자 에이전트로, 실시간
    > 항공편 정보를 조회합니다.^31^

- **인간 참여형(Human-in-the-Loop) 통합:** 감독자 에이전트는 사용자의
  > 요청이 모호하거나 추가 정보가 필요하다고 판단될 경우, 워크플로우를
  > human_interrupt 노드로 라우팅할 수 있습니다. 이 노드는 그래프의
  > 실행을 일시 중지하고 사용자에게 명확한 설명을 요청합니다. 사용자가
  > 입력을 제공하면, 그래프는 그 정보를 바탕으로 다시 실행을 재개합니다.
  > 이는 자동화된 실행과 인간의 감독 및 제어를 원활하게 결합하는 방법을
  > 보여주는 강력한 예시입니다.^31^

이러한 청사진들을 분석해 보면 한 가지 공통적인 경향이 드러납니다. 바로
\'메타 에이전트(Meta-Agents)\' 또는 \'시스템 에이전트(System-Agents)\'의
부상입니다. 계획자, 재계획자, 평가자, 감독자와 같은 에이전트들은
사용자의 문제를 직접 해결하는 대신, 문제 해결 *과정* 자체를 추론하고
관리합니다. 계획자는 워크플로우를 생성하고, 평가자는 중간 단계의 품질을
검증하며, 감독자는 다른 에이전트들을 관리합니다. 이는 더 자율적이고 자기
수정이 가능한 시스템으로 나아가기 위한 중요한 단계이며, 에이전트가
자신의 작업을 성찰하고 개선하는 능력을 갖추게 됨을 의미합니다.

## **6. 프로덕션 등급 시스템을 위한 권장 사항** {#프로덕션-등급-시스템을-위한-권장-사항}

프로토타입 단계의 복잡한 에이전트 시스템을 안정적이고 신뢰할 수 있는
프로덕션 환경으로 이전하기 위해서는 몇 가지 중요한 엔지니어링 고려
사항이 필요합니다. 이 섹션에서는 견고성, 제어 가능성, 그리고 평가 및
디버깅을 위한 실질적인 지침을 제공합니다.

### **6.1. 복원력 설계를 위한 오류 처리, 재시도 및 대체 전략** {#복원력-설계를-위한-오류-처리-재시도-및-대체-전략}

실세계의 API는 불안정할 수 있고, LLM은 예측 불가능한 출력을 생성할 수
있으며, 도구 실행은 언제든 실패할 수 있습니다. 프로덕션 시스템은 이러한
실패 상황을 우아하게 처리할 수 있어야 합니다.

- **구현:** LangGraph의 조건부 엣지는 견고한 오류 처리 루프를 구축하는
  > 데 이상적입니다. 외부 도구를 실행하는 노드는 try\...except 블록으로
  > 감싸야 합니다. 예외가 발생하면, 노드는 상태(State)의 error 플래그를
  > True로 설정하고 error_count를 1 증가시킨 후 상태를 반환합니다. 이
  > 노드에 연결된 조건부 엣지는 error 플래그와 error_count를 확인합니다.
  > error_count가 미리 정해진 임계값(예: 3회) 미만이면 동일한 노드로
  > 다시 라우팅하여 재시도를 수행하고, 임계값을 초과하면 사용자에게
  > 실패를 알리거나 다른 대체 도구를 사용하는 fallback 노드로 라우팅할
  > 수 있습니다.^10^  
  > Python  
  > def execute_tool_node(state: AgentState) -\> AgentState:  
  > try:  
  > \# 도구 실행 로직  
  > result = some_tool.invoke(\...)  
  > state\[\'tool_outputs\'\] = result  
  > state\[\'error\'\] = False  
  > except Exception as e:  
  > state\[\'error\'\] = True  
  > state\[\'error_count\'\] = state.get(\'error_count\', 0) + 1  
  > state\[\'error_message\'\] = str(e)  
  > return state  
  >   
  > def route_after_tool_execution(state: AgentState):  
  > if state.get(\'error\'):  
  > if state.get(\'error_count\', 0) \>= 3:  
  > return \"fallback_node\"  
  > else:  
  > return \"execute_tool_node\" \# 재시도  
  > else:  
  > return \"next_step_node\"

### **6.2. 검증 및 제어를 위한 인간 참여형(Human-in-the-Loop) 통합** {#검증-및-제어를-위한-인간-참여형human-in-the-loop-통합}

모든 작업을 완전히 자동화하는 것이 바람직하지 않거나 불가능한 경우가
많습니다. 특히 금융 거래, 의료 진단, 법률 문서 초안 작성과 같이 높은
정확성과 책임이 요구되는 작업에서는 인간의 최종 승인이나 수정이
필수적입니다. LangGraph는 설계 단계부터 인간과 에이전트의 협업을 염두에
두고 만들어졌습니다.^1^

- **구현:** 그래프의 특정 지점에서 human_interrupt 노드로 전환하여
  > 실행을 일시 중지시킬 수 있습니다. 이 노드는 현재까지의 에이전트
  > 상태(예: 에이전트가 작성한 이메일 초안, 제안된 실행 계획 등)를
  > 사용자에게 제시하고 입력을 기다립니다. 사용자는 제시된 내용을
  > 검토하고, 승인하거나, 수정된 내용을 입력할 수 있습니다. 사용자의
  > 피드백은 다시 상태에 반영되고, 그래프는 중단된 지점부터 실행을
  > 재개합니다. 이 메커니즘은 에이전트의 자율성과 인간의 통제력 사이에서
  > 균형을 맞추는 데 매우 중요합니다.^45^

### **6.3. 평가 및 디버깅 프레임워크** {#평가-및-디버깅-프레임워크}

복잡한 멀티 에이전트 시스템의 동작을 이해하고 개선하기 위해서는 체계적인
평가와 디버깅 도구가 필수적입니다.

- **LangSmith를 통한 추적 및 관찰 가능성:** 멀티 에이전트 시스템에서
  > print 문을 이용한 디버깅은 거의 불가능에 가깝습니다. LangSmith와
  > 같은 추적 도구는 전체 실행 흐름, 각 노드에서의 상태 변화, LLM
  > 입출력, 도구 호출 내용 등을 시각적으로 추적할 수 있는 필수적인 관찰
  > 가능성(observability)을 제공합니다. 이를 통해 개발자는 시스템의 병목
  > 현상을 식별하고, 특정 노드의 성능을 분석하며, 예기치 않은 동작의
  > 근본 원인을 신속하게 파악할 수 있습니다.^46^

- **다중 턴 상호작용 평가:** 대화형 에이전트의 성능은 단발성
  > 질의응답으로 평가할 수 없습니다. 전체 대화의 맥락에서 평가가
  > 이루어져야 합니다. 이를 위해 **다중 턴 시뮬레이션(multi-turn
  > simulation)** 기법을 사용할 수 있습니다. 이 기법은 또 다른 LLM을
  > \'시뮬레이션된 사용자\'로 사용하여, 개발 중인 챗봇과 여러 턴에 걸쳐
  > 가상의 대화를 진행시킵니다. openevals와 같은 프레임워크는 이러한
  > 시뮬레이션을 지원하며, 대화가 끝난 후 전체 대화 기록(trajectory)을
  > 바탕으로 맥락 유지 능력, 장기 기억 활용도, 최종 과업 성공 여부 등을
  > 종합적으로 평가할 수 있습니다. 이는 반복적인 행동이나 맥락 손실과
  > 같은 미묘한 문제를 감지하는 데 매우 효과적입니다.^48^

이러한 프로덕션 지향적인 설계 원칙들을 적용함으로써, 개발자는
LangGraph로 구축한 에이전트 시스템이 실제 환경의 불확실성과 복잡성
속에서도 안정적으로 작동하도록 보장할 수 있습니다.

## **결론**

본 기술 백서는 LangGraph를 활용하여 복잡하고 상호작용적인 멀티 에이전트
챗봇을 설계하고 구현하는 데 필요한 핵심 원리, 아키텍처 패턴, 그리고
구체적인 기술들을 심도 있게 분석했다. 분석을 통해 LangGraph는 단순히 LLM
애플리케이션을 구축하는 라이브러리를 넘어, 상태 기반의 순환적이고
모듈화된 지능형 시스템을 구축하기 위한 근본적인 패러다임의 전환을
제시한다는 점이 명확해졌다.

StateGraph와 상태 관리 아키텍처는 시스템의 모든 데이터 흐름과 컨텍스트를
정의하는 청사진 역할을 하며, 조건부 엣지는 에이전트가 동적으로 판단하고
행동하는 지능의 핵심 메커니즘을 제공한다. 도구 호출과 메모리 관리
아키텍처는 에이전트가 외부 세계와 상호작용하고 과거의 경험으로부터
학습할 수 있는 능력을 부여한다.

특히, Supervisor-Worker, 계층적 에이전트 팀, 그리고 Plan-and-Execute와
같은 멀티 에이전트 아키텍처는 복잡한 문제를 작고 관리 가능한 단위로
분해하여 해결하는 강력한 전략을 제공한다. Supervisor-Worker 패턴은 중앙
집중식 조율을 통해 전문화된 작업자들을 효율적으로 관리하며, 계층적
에이전트 팀은 이를 재귀적으로 적용하여 인간의 조직 구조와 유사한 확장
가능한 \"팀의 팀\" 구조를 형성한다. 이러한 패턴들은 에이전트 설계가 단일
개체의 지능을 넘어, 여러 지능체가 협력하는 \'집단 지성(Collective
Intelligence)\'의 형태로 발전하고 있음을 보여준다.

결론적으로, LangGraph는 개발자에게 전례 없는 수준의 제어력과 유연성을
제공함으로써, 더욱 견고하고, 확장 가능하며, 신뢰할 수 있는 에이전트
시스템의 시대를 열고 있다. 본 백서에서 제시된 아키텍처와 설계 원칙들은
AI 개발자와 아키텍트가 프로토타입을 넘어 실제 프로덕션 환경에서 가치를
창출하는 차세대 AI 애플리케이션을 구축하는 데 있어 견고한 기술적 토대가
될 것이다. 앞으로의 발전은 이러한 에이전틱 패턴들을 더욱 정교하게
조합하고, 자기 평가 및 자기 수정 능력을 고도화하며, 더욱 복잡한 협업
전략을 탐구하는 방향으로 나아갈 것으로 전망된다.

#### 참고 자료

1.  LangGraph Tutorial: Building LLM Agents with LangChain\'s Agent
    > Framework - Zep, 7월 14, 2025에 액세스,
    > [[https://www.getzep.com/ai-agents/langgraph-tutorial]{.underline}](https://www.getzep.com/ai-agents/langgraph-tutorial)

2.  LangGraph - LangChain, 7월 14, 2025에 액세스,
    > [[https://www.langchain.com/langgraph]{.underline}](https://www.langchain.com/langgraph)

3.  Mastering LangGraph: A Beginner\'s Guide to Building Intelligent
    > \..., 7월 14, 2025에 액세스,
    > [[https://medium.com/@cplog/introduction-to-langgraph-a-beginners-guide-14f9be027141]{.underline}](https://medium.com/@cplog/introduction-to-langgraph-a-beginners-guide-14f9be027141)

4.  LangGraph: Build Stateful AI Agents in Python -- Real Python, 7월
    > 14, 2025에 액세스,
    > [[https://realpython.com/langgraph-python/]{.underline}](https://realpython.com/langgraph-python/)

5.  LangGraph Glossary - GitHub Pages, 7월 14, 2025에 액세스,
    > [[https://langchain-ai.github.io/langgraph/concepts/low_level/]{.underline}](https://langchain-ai.github.io/langgraph/concepts/low_level/)

6.  Learn LangGraph basics - Overview, 7월 14, 2025에 액세스,
    > [[https://langchain-ai.github.io/langgraph/concepts/why-langgraph/]{.underline}](https://langchain-ai.github.io/langgraph/concepts/why-langgraph/)

7.  LangGraph RAG Agent Tutorial \| Basics to Advanced Multi-Agent AI
    > Chatbot \| With Code, 7월 14, 2025에 액세스,
    > [[https://www.youtube.com/watch?v=60XDTWhklLA]{.underline}](https://www.youtube.com/watch?v=60XDTWhklLA)

8.  Building Supervisor Architecture with LangGraph \| by Diwakar
    > Kumar - Medium, 7월 14, 2025에 액세스,
    > [[https://medium.com/@diwakarkumar_18755/building-supervisor-architecture-with-langgraph-0719c44f2718]{.underline}](https://medium.com/@diwakarkumar_18755/building-supervisor-architecture-with-langgraph-0719c44f2718)

9.  Building Multi-Agent Systems with LangGraph: A Step-by-Step Guide \|
    > by Sushmita Nandi, 7월 14, 2025에 액세스,
    > [[https://medium.com/@sushmita2310/building-multi-agent-systems-with-langgraph-a-step-by-step-guide-d14088e90f72]{.underline}](https://medium.com/@sushmita2310/building-multi-agent-systems-with-langgraph-a-step-by-step-guide-d14088e90f72)

10. Advanced LangGraph: Implementing Conditional Edges and Tool \...,
    > 7월 14, 2025에 액세스,
    > [[https://dev.to/jamesli/advanced-langgraph-implementing-conditional-edges-and-tool-calling-agents-3pdn]{.underline}](https://dev.to/jamesli/advanced-langgraph-implementing-conditional-edges-and-tool-calling-agents-3pdn)

11. 1\. Build a basic chatbot - GitHub Pages, 7월 14, 2025에 액세스,
    > [[https://langchain-ai.github.io/langgraph/tutorials/get-started/1-build-basic-chatbot/]{.underline}](https://langchain-ai.github.io/langgraph/tutorials/get-started/1-build-basic-chatbot/)

12. Plan-and-Execute - GitHub Pages, 7월 14, 2025에 액세스,
    > [[https://langchain-ai.github.io/langgraph/tutorials/plan-and-execute/plan-and-execute/]{.underline}](https://langchain-ai.github.io/langgraph/tutorials/plan-and-execute/plan-and-execute/)

13. LangGraph Simplified: Understanding Conditional edge using Hotel
    > \..., 7월 14, 2025에 액세스,
    > [[https://medium.com/@Shamimw/langgraph-simplified-understanding-conditional-edge-using-hotel-guest-check-in-process-36adfe3380a8]{.underline}](https://medium.com/@Shamimw/langgraph-simplified-understanding-conditional-edge-using-hotel-guest-check-in-process-36adfe3380a8)

14. LangGraph for Beginners, Part 3: Conditional Edges \| by Santosh
    > Rout \| AI Agents - Medium, 7월 14, 2025에 액세스,
    > [[https://medium.com/ai-agents/langgraph-for-beginners-part-3-conditional-edges-16a3aaad9f31]{.underline}](https://medium.com/ai-agents/langgraph-for-beginners-part-3-conditional-edges-16a3aaad9f31)

15. Tool-Calling AI Agents with Langchain & Langgraph - Medium, 7월 14,
    > 2025에 액세스,
    > [[https://medium.com/@cplog/building-tool-calling-conversational-ai-with-langchain-and-langgraph-a-beginners-guide-8d6986cc589e]{.underline}](https://medium.com/@cplog/building-tool-calling-conversational-ai-with-langchain-and-langgraph-a-beginners-guide-8d6986cc589e)

16. Building an Agentic RAG with LangGraph: A Step-by-Step Guide -
    > Medium, 7월 14, 2025에 액세스,
    > [[https://medium.com/@wendell_89912/building-an-agentic-rag-with-langgraph-a-step-by-step-guide-009c5f0cce0a]{.underline}](https://medium.com/@wendell_89912/building-an-agentic-rag-with-langgraph-a-step-by-step-guide-009c5f0cce0a)

17. Intelligent Spark Agents: A Modular LangGraph Framework for
    > Scalable, Visualized, and Enhanced Big Data Machine Learning
    > Workflows - arXiv, 7월 14, 2025에 액세스,
    > [[https://arxiv.org/html/2412.01490v2]{.underline}](https://arxiv.org/html/2412.01490v2)

18. Plan-and-Execute Agents - LangChain Blog, 7월 14, 2025에 액세스,
    > [[https://blog.langchain.com/planning-agents/]{.underline}](https://blog.langchain.com/planning-agents/)

19. How to Develop Multi-agent Chatbots with LangGraph Agents \..., 7월
    > 14, 2025에 액세스,
    > [[https://wellsr.com/python/multi-agent-chatbot-with-langgraph-agents/]{.underline}](https://wellsr.com/python/multi-agent-chatbot-with-langgraph-agents/)

20. Tool calling \| 🦜️ LangChain, 7월 14, 2025에 액세스,
    > [[https://python.langchain.com/docs/concepts/tool_calling/]{.underline}](https://python.langchain.com/docs/concepts/tool_calling/)

21. Call tools - GitHub Pages, 7월 14, 2025에 액세스,
    > [[https://langchain-ai.github.io/langgraph/how-tos/tool-calling/]{.underline}](https://langchain-ai.github.io/langgraph/how-tos/tool-calling/)

22. Agents - GitHub Pages, 7월 14, 2025에 액세스,
    > [[https://langchain-ai.github.io/langgraph/reference/agents/]{.underline}](https://langchain-ai.github.io/langgraph/reference/agents/)

23. LangGraph : Tool calling Agents. This article assumes reader have
    > \..., 7월 14, 2025에 액세스,
    > [[https://shakti-pawar.medium.com/langgraph-tool-calling-agents-02fdfbd86e8b]{.underline}](https://shakti-pawar.medium.com/langgraph-tool-calling-agents-02fdfbd86e8b)

24. Build a Chatbot \| 🦜️ LangChain, 7월 14, 2025에 액세스,
    > [[https://python.langchain.com/docs/tutorials/chatbot/]{.underline}](https://python.langchain.com/docs/tutorials/chatbot/)

25. LangGraph memory - Overview, 7월 14, 2025에 액세스,
    > [[https://langchain-ai.github.io/langgraph/concepts/memory/]{.underline}](https://langchain-ai.github.io/langgraph/concepts/memory/)

26. langchain-ai/memory-agent - GitHub, 7월 14, 2025에 액세스,
    > [[https://github.com/langchain-ai/memory-agent]{.underline}](https://github.com/langchain-ai/memory-agent)

27. langchain/docs/docs/versions/migrating_memory/long_term_memory_agent.ipynb
    > at master - GitHub, 7월 14, 2025에 액세스,
    > [[https://github.com/langchain-ai/langchain/blob/master/docs/docs/versions/migrating_memory/long_term_memory_agent.ipynb]{.underline}](https://github.com/langchain-ai/langchain/blob/master/docs/docs/versions/migrating_memory/long_term_memory_agent.ipynb)

28. LangGraph Multi-Agent Systems - Overview, 7월 14, 2025에 액세스,
    > [[https://langchain-ai.github.io/langgraph/concepts/multi_agent/]{.underline}](https://langchain-ai.github.io/langgraph/concepts/multi_agent/)

29. Multi-Agent System Tutorial with LangGraph - FutureSmart AI Blog,
    > 7월 14, 2025에 액세스,
    > [[https://blog.futuresmart.ai/multi-agent-system-with-langgraph]{.underline}](https://blog.futuresmart.ai/multi-agent-system-with-langgraph)

30. Building Multi-Agent Systems with LangGraph-Supervisor - DEV \...,
    > 7월 14, 2025에 액세스,
    > [[https://dev.to/sreeni5018/building-multi-agent-systems-with-langgraph-supervisor-138i]{.underline}](https://dev.to/sreeni5018/building-multi-agent-systems-with-langgraph-supervisor-138i)

31. A Step-by-Step Guide on how to build a Multi-Agent Chatbot, 7월 14,
    > 2025에 액세스,
    > [[https://techifysolutions.com/blog/building-a-multi-agent-chatbot-with-langgraph/]{.underline}](https://techifysolutions.com/blog/building-a-multi-agent-chatbot-with-langgraph/)

32. Agent Supervisor, 7월 14, 2025에 액세스,
    > [[https://langchain-ai.github.io/langgraphjs/tutorials/multi_agent/agent_supervisor/]{.underline}](https://langchain-ai.github.io/langgraphjs/tutorials/multi_agent/agent_supervisor/)

33. Agentic RAG - GitHub Pages, 7월 14, 2025에 액세스,
    > [[https://langchain-ai.github.io/langgraph/tutorials/rag/langgraph_agentic_rag/]{.underline}](https://langchain-ai.github.io/langgraph/tutorials/rag/langgraph_agentic_rag/)

34. LangGraph: Hierarchical Agent Teams - Kaggle, 7월 14, 2025에 액세스,
    > [[https://www.kaggle.com/code/ksmooi/langgraph-hierarchical-agent-teams]{.underline}](https://www.kaggle.com/code/ksmooi/langgraph-hierarchical-agent-teams)

35. Hierarchical Agent Teams - GitHub Pages, 7월 14, 2025에 액세스,
    > [[https://langchain-ai.github.io/langgraph/tutorials/multi_agent/hierarchical_agent_teams/]{.underline}](https://langchain-ai.github.io/langgraph/tutorials/multi_agent/hierarchical_agent_teams/)

36. Hierarchical multi-agent systems with LangGraph - YouTube, 7월 14,
    > 2025에 액세스,
    > [[https://www.youtube.com/watch?v=B_0TNuYi56w&pp=0gcJCfwAo7VqN5tD]{.underline}](https://www.youtube.com/watch?v=B_0TNuYi56w&pp=0gcJCfwAo7VqN5tD)

37. Hierarchical Agent Teams - GitHub Pages, 7월 14, 2025에 액세스,
    > [[https://langchain-ai.github.io/langgraphjs/tutorials/multi_agent/hierarchical_agent_teams/]{.underline}](https://langchain-ai.github.io/langgraphjs/tutorials/multi_agent/hierarchical_agent_teams/)

38. alidhl/multi-agent-chatbot - GitHub, 7월 14, 2025에 액세스,
    > [[https://github.com/alidhl/multi-agent-chatbot]{.underline}](https://github.com/alidhl/multi-agent-chatbot)

39. LangGraph Tutorial: Build Your Own AI Coding Agent - Medium, 7월 14,
    > 2025에 액세스,
    > [[https://medium.com/@mariumaslam499/build-your-own-ai-coding-agent-with-langgraph-040644343e73]{.underline}](https://medium.com/@mariumaslam499/build-your-own-ai-coding-agent-with-langgraph-040644343e73)

40. raghavmanoharanjayanthi30/AgenticRAG_LangGraph - GitHub, 7월 14,
    > 2025에 액세스,
    > [[https://github.com/raghavmanoharanjayanthi30/AgenticRAG_LangGraph]{.underline}](https://github.com/raghavmanoharanjayanthi30/AgenticRAG_LangGraph)

41. Agentic RAG With LangGraph - Qdrant, 7월 14, 2025에 액세스,
    > [[https://qdrant.tech/documentation/agentic-rag-langgraph/]{.underline}](https://qdrant.tech/documentation/agentic-rag-langgraph/)

42. Agentic RAG: Step-by-Step Tutorial With Demo Project - DataCamp, 7월
    > 14, 2025에 액세스,
    > [[https://www.datacamp.com/tutorial/agentic-rag-tutorial]{.underline}](https://www.datacamp.com/tutorial/agentic-rag-tutorial)

43. Agentic RAG \| LangChain OpenTutorial - GitBook, 7월 14, 2025에
    > 액세스,
    > [[https://langchain-opentutorial.gitbook.io/langchain-opentutorial/17-langgraph/02-structures/06-langgraph-agentic-rag]{.underline}](https://langchain-opentutorial.gitbook.io/langchain-opentutorial/17-langgraph/02-structures/06-langgraph-agentic-rag)

44. gotsulyakk/agentic-rag: Agentic RAG implementation using LangGraph -
    > GitHub, 7월 14, 2025에 액세스,
    > [[https://github.com/gotsulyakk/agentic-rag]{.underline}](https://github.com/gotsulyakk/agentic-rag)

45. LangGraph Crash Course \#33 - Human In The Loop - Multi-turn
    > Conversations - YouTube, 7월 14, 2025에 액세스,
    > [[https://www.youtube.com/watch?v=QItYUlt5ABk]{.underline}](https://www.youtube.com/watch?v=QItYUlt5ABk)

46. LangGraph Crash Course With Code Examples - YouTube, 7월 14, 2025에
    > 액세스,
    > [[https://www.youtube.com/watch?v=lQ5r2AvlP0Q]{.underline}](https://www.youtube.com/watch?v=lQ5r2AvlP0Q)

47. langchain-ai/langgraph: Build resilient language agents as graphs. -
    > GitHub, 7월 14, 2025에 액세스,
    > [[https://github.com/langchain-ai/langgraph]{.underline}](https://github.com/langchain-ai/langgraph)

48. Why Do Multi-Agent LLM Systems Fail? - arXiv, 7월 14, 2025에 액세스,
    > [[https://arxiv.org/pdf/2503.13657]{.underline}](https://arxiv.org/pdf/2503.13657)

49. How to simulate multi-turn interactions - ️🛠️ LangSmith - LangChain,
    > 7월 14, 2025에 액세스,
    > [[https://docs.smith.langchain.com/evaluation/how_to_guides/multi_turn_simulation]{.underline}](https://docs.smith.langchain.com/evaluation/how_to_guides/multi_turn_simulation)
